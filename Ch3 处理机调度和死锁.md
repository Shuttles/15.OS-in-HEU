重点

1. 掌握***<u>进程调度</u>***算法，各适用于何种情况
2. 理解常用的几种***<u>实时</u>******<u>调度算法</u>***
3. 理解产生***<u>死锁</u>***的原因
4. 掌握***<u>银行家算法</u>***避免死锁



难点

1. 多道程序设计中的各种调度算法
2. ***<u>响应比高者优先调度算法</u>***的设计过程
3. ***<u>银行家算法</u>***







为什么要学习这章？

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gdufo99xmyj30og0hudif.jpg)







# 1.处理机(CPU)调度的基本概念

## 1.1高级、中级和低级调度

### 作业

1. 作业是用户在一个事务处理过程中==要求计算机系统所做工作的集合==，包括用户程序、所需的数据及命令等。

2. 作业的状态

   一个作业进入系统到运行结束，一般需要经历收容、运行、完成三个阶段，与之相对应的是作业的三种状态

   + 后备状态
   + 运行状态
   + 完成状态

3. 作业状态间转换

   ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gdufuegpf9j30rg0cagmi.jpg)



### 高级调度(High Scheduling)

也称***<u>作业调度</u>***或***<u>长程调度</u>***(Long-Term Scheduling)

1. 主要任务是按一定的原则对==外存上处于后备状态的作业==进行选择，给选中的作业分配内存、I/O设备等必要的资源，并建立相应的进程，放入***<u>就绪队列</u>***，以使该作业的进程获得竞争CPU的权利
2. 也称为***<u>接纳调度</u>***(Admission Scheduling)
3. 高级调度的时间尺度通常是***<u>分钟、小时或天</u>***
4. ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gdug2o0nt2j30n50fwmyu.jpg)



### 低级调度

也称***<u>进程调度</u>***或***<u>短程调度</u>***(Short-Term Scheduling)

1. 主要任务是==按照某种策略和方法选取一个处于就绪状态的进程，将CPU分配给它==
2. 常见的低级调度***<u>有非抢占式</u>***和***<u>抢占式</u>***
3. 低级调度时间尺度通常是***<u>毫秒级</u>***的。由于低级调度算法的频繁使用，要求在实现时做到高效。



### 中级调度(Intermediate-Level Scheduling)

也称***<u>中程调度</u>***(Medium-Term Scheduling)

1. 引入目的是为了***<u>提高内存利用率和系统吞吐量</u>***。是那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待
2. 主要任务是按照给定的原则和策略，==将处于外存swap区中的重又具备运行条件的就绪进程调入内存==，或==将处于内存就绪状态或阻塞状态的进程交换到外存swap区==。



## 1.2进程调度的任务

是==控制、协调进程对CPU的竞争==，即按一定的调度算法从就绪队列中选中一个进程，把CPU的使用权交给被选中的进程。



## 1.3确定算法的原则

1. 具有公平性
2. 资源利用率高(特别是CPU利用率)
3. 在交互式系统情况下要追求***<u>响应时间</u>***(越短越好)
4. 在批处理系统情况下要追求***<u>系统吞吐量</u>***



## 1.4进程调度方式

### 非抢占方式(Non-preemptive Mode)

1. 当某一进程正在CPUrunning时，即使有某个更为重要或紧迫的进程进入就绪队列，该进程仍继续执行，直到其完成或发生某种事件而进入完成或阻塞状态时，才把CPU分配给更为重要或紧迫的进程

2. 引起进程调度的因素

   + 正在执行的进程执行完毕，或因发生某事件而不能再仅需执行
   + 执行中的进程因提出I/O请求而暂停执行
   + 在进程通信或进程同步过程中执行了某种原语操作如wait block wakeup等原语

3. 优点

   算法简单，系统开销小

4. 缺点

   紧急任务不能及时响应，短进程到达要等待长进程运行结束



### 抢占方式(Preemptive Mode)

1. 当某一进程正在CPUrunning时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在执行的进程，将CPU分配给这个更为重要或紧迫的进程

2. 抢占式调度主要有以下原则

   + 优先级高原则

   + 短作业(进程)优先原则

   + 时间片原则

     即时间片用完后停止执行，重新进行调度，适用于分时系统

3. 优点

   适用于时间要求严格的实时系统

4. 缺点

   调度算法复杂，系统开销大



## 1.5调度队列模型







# 2.调度算法





# 3.实时调度









# 4.多处理机系统中的调度

## 这节不讲







# 5.产生死锁的原因和必要条件

## 5.1死锁的基本概念

### 死锁的概念

1. 指***<u>多个进程</u>***因***<u>竞争共享资源</u>***而造成的一种***<u>僵局</u>***。若无外力作用，这些进程都将永远不能再向前推进。

2. 即 一组进程中，每个进程都无限等待***<u>被该组进程中另一进程所占有的资源</u>***，因而永远无法得到所需资源。

   这种现象称为进程死锁，这一组进程就成为死锁进程。



###   关于死锁的一些结论

1. 参与死锁的进程***<u>至少是两个</u>***
2. 参与死锁的进程***<u>至少有两个已经占有资源</u>***
3. ***<u>参与死锁的所有进程</u>***都在等待资源
4. 参与死锁的所有进程是当前***<u>系统中所有进程的子集</u>***
5. 如果死锁发生，会浪费大量系统资源，甚至导致系统崩溃





## 5.2产生死锁的原因

==竞争共享资源引起进程死锁==

1. 可剥夺和非剥夺性资源

   + 前者比如CPU、内存等
   + 后者比如磁带机、打印机等

2. 竞争非剥夺性资源

   系统中的非剥夺性资源由于数量有限而不能满足进程运行的需要，进程在运行过程中因争夺这些资源而***<u>陷入僵局</u>***

3. 竞争临时性资源

   如信号量、中断信号、同步信号等





## 5.3产生死锁的必要条件

1. ***<u>互斥条件</u>***
   + 进程对所分配到的资源进行==排他性使用==
2. ***<u>保持和请求条件</u>***
   + 进程已经至少保持了一个资源，但又提出了新的资源请求，而该资源又已被其他进程占有
3. ***<u>不剥夺条件</u>***
   + 进程已获得的资源在未使用完之前不能被剥夺
4. ***<u>环路等待条件</u>***
   + 在发生死锁时，必然存在一个进程--资源循环等待的环形链





## 5.4处理死锁的基本方法

1. 预防死锁
2. 避免死锁
3. 检测死锁
4. 解除死锁



![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1ge2b6aocy7j30vg0iwwi6.jpg)



# 6.预防死锁的方法

## 6.1预防死锁

1. ***<u>摒弃“保持和请求”条件</u>***
   + 所有进程再开始运行之前必须一次性地申请整个运行过程所需的全部资源(***<u>And型信号量</u>***)
   + 简单、易于实现、安全
   + 资源浪费严重
2. ***<u>摒弃“不剥夺”条件</u>***
   + 进程逐个地申请所需资源
   + 当一个已经保持了某些资源的进程申请新资源***<u>而不能得到满足</u>***时，必须放弃所有已保持的资源
   + 实现复杂、代价高昂
3. ***<u>摒弃“环路等待”条件</u>***
   + 系统将所有资源按类型分配序号并排队
   + 所有进程***<u>申请资源必须按序号递增的顺序</u>***
   + 资源利用率和系统吞吐量较高
   + 但在资源管理和资源申请方面仍有问题





## 6.2系统安全状态

1. ***<u>安全状态</u>***

   + 在避免死锁的方法中，允许进程==动态地==申请资源，但系统在进行资源分配之前，应==先计算此次资源分配的安全性==。若此次分配不会导致系统进入不安全状态，则将资源分配给进程。否则，令进程等待。
   + 所谓==安全状态==，是指***<u>系统能按某种进程顺序</u>***(P1, P2, ..., Pn)，来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。

2. 安全状态举例

   ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1ge2k2zjdm5j30pf0he0un.jpg)

   ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1ge2k341fbhj30qz0gadiy.jpg)

   

## 6.3利用银行家算法避免死锁

### 6.3.1银行家算法中的数据结构

1. 可利用资源向量Available



# 7.死锁的检测与解除

 